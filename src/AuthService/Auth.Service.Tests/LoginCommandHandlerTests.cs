using Auth.Domain;
using Auth.Service.Commands;
using Auth.Service.Repositories;
using Moq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using FluentAssertions;
using System.Threading;

namespace Auth.Service.Tests
{
    public class LoginCommandHandlerTests
    {
        //email not found
        //unverified email
        //password not correct
        //happy path

        private readonly Mock<IRefreshTokenRepository> _refreshTokenRepositoryMock;
        private readonly Mock<IUserRepository> _userRepositoryMock;
        private readonly Mock<IEncryptor> _encryptorMock;
        private readonly Mock<IEmailValidator> _emailValidatorMock;
        private readonly Mock<ITokenService> _tokenServiceMock;

        readonly LoginCommandHandler _handler;

        public LoginCommandHandlerTests()
        {
            _refreshTokenRepositoryMock = new Mock<IRefreshTokenRepository>();
            _userRepositoryMock = new Mock<IUserRepository>();
            _encryptorMock = new Mock<IEncryptor>();
            _emailValidatorMock = new Mock<IEmailValidator>();
            _tokenServiceMock = new Mock<ITokenService>();
            _handler = new LoginCommandHandler(_userRepositoryMock.Object, _encryptorMock.Object, _emailValidatorMock.Object, _tokenServiceMock.Object, _refreshTokenRepositoryMock.Object);
        }

        [Fact]
        public async Task Handle_Should_ReturnErorIfUserNotFound()
        {

            _emailValidatorMock.Setup(m => m.Validate(It.IsAny<string>()))
                .Returns(true);
            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync((User)null);

            var command = new LoginCommand("someone@abc.com", "password");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(LoginCommandHandler.Email_Or_Password_Not_Correct);

        }

        [Fact]
        public async Task Handle_Should_ReturnErrorIfPasswordNotCorrect()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", true, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);

            _emailValidatorMock.Setup(m => m.Validate(It.IsAny<string>()))
                .Returns(true);

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            _encryptorMock.Setup(m => m.ComputeHash(It.IsAny<string>(), It.IsAny<string>()))
                .Returns("some random password hash");

            var command = new LoginCommand("someone@abc.com", "password");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(LoginCommandHandler.Email_Or_Password_Not_Correct);

        }

        [Fact]
        public async Task Handle_Should_ReturnErrorIfEmailIsNotVerified()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", false, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);

            _emailValidatorMock.Setup(m => m.Validate(It.IsAny<string>()))
                .Returns(true);

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            _encryptorMock.Setup(m => m.ComputeHash(It.IsAny<string>(), It.IsAny<string>()))
                .Returns("some random password hash");

            var command = new LoginCommand("someone@abc.com", "password");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(LoginCommandHandler.Email_Is_Unverified);

        }

        [Fact]
        public async Task Handle_Should_Succeede()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", true, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);
            var token = "token generated by login process";
            _emailValidatorMock.Setup(m => m.Validate(It.IsAny<string>()))
                .Returns(true);

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            _encryptorMock.Setup(m => m.ComputeHash(It.IsAny<string>(), It.IsAny<string>()))
                .Returns(user.PasswordHash);

            _tokenServiceMock.Setup(m => m.GenerateToken(It.IsAny<UserInfo>()))
                .Returns(token);

            var command = new LoginCommand("someone@abc.com", "password");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().NotBeNull();
            result.ErrorMessages.Should().BeEmpty();
            result.Value.Token.Should().Be(token);
            result.Value.RefreshToken.Should().NotBeNull();

        }

        private static CancellationToken GetCancellationToken()
        {
            var tokenSource = new CancellationTokenSource();
            var token = tokenSource.Token;
            return token;
        }
    }
}
