using Auth.Domain;
using Auth.Service.Commands;
using Auth.Service.Repositories;
using Moq;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Xunit;
using FluentAssertions;
using System.Threading;

namespace Auth.Service.Tests
{
    public class RefreshTokenCommandHandlerTests
    {
        //email not found
        //invalid token
        //happy path

        private readonly Mock<IRefreshTokenRepository> _refreshTokenRepositoryMock;
        private readonly Mock<IUserRepository> _userRepositoryMock;
        private readonly Mock<ITokenService> _tokenServiceMock;

        readonly RefreshTokenCommandHandler _handler;

        public RefreshTokenCommandHandlerTests()
        {
            _refreshTokenRepositoryMock = new Mock<IRefreshTokenRepository>();
            _userRepositoryMock = new Mock<IUserRepository>();
            _tokenServiceMock = new Mock<ITokenService>();
            _handler = new RefreshTokenCommandHandler(_userRepositoryMock.Object, _refreshTokenRepositoryMock.Object, _tokenServiceMock.Object);
        }

        [Fact]
        public async Task Handle_Should_ReturnErorIfUserNotFound()
        {
            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync((User)null);

            var command = new RefreshTokenCommand("someone@abc.com", "refresh token");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(RefreshTokenCommandHandler.Invalid_Refresh_Token);

        }

        [Fact]
        public async Task Handle_Should_ReturnErorIfTokenIsNotFound()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", false, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            var command = new RefreshTokenCommand("someone@abc.com", "refresh token");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(RefreshTokenCommandHandler.Invalid_Refresh_Token);

        }

        [Fact]
        public async Task Handle_Should_ReturnErorIfTokenIsDifferent()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", false, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            _refreshTokenRepositoryMock.Setup(m => m.GetRefreshToken(user.Email))
                .ReturnsAsync("different token");

            var command = new RefreshTokenCommand("someone@abc.com", "refresh token");

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().BeNull();
            result.ErrorMessages.Should().Contain(RefreshTokenCommandHandler.Invalid_Refresh_Token);

        }

        [Fact]
        public async Task Handle_Should_Succeed()
        {
            var user = new User("someone@abc.com", "firstname", "lastname", false, "salt", "password", DateTime.UtcNow, DateTime.UtcNow);
            var token = "token generated by login process";
            var refreshToken = "refresh token";

            _userRepositoryMock.Setup(m => m.Get(It.IsAny<string>()))
                .ReturnsAsync(user);

            _refreshTokenRepositoryMock.Setup(m => m.GetRefreshToken(user.Email))
                .ReturnsAsync(refreshToken);

            _tokenServiceMock.Setup(m => m.GenerateToken(It.IsAny<UserInfo>()))
                .Returns(token);

            var command = new RefreshTokenCommand("someone@abc.com", refreshToken);

            var result = await _handler.Handle(command, GetCancellationToken());

            result.Should().NotBeNull();
            result.Value.Should().NotBeNull();
            result.ErrorMessages.Should().BeEmpty();
            result.Value.Token.Should().Be(token);
            result.Value.RefreshToken.Should().NotBeNull();

        }

        private static CancellationToken GetCancellationToken()
        {
            var tokenSource = new CancellationTokenSource();
            var token = tokenSource.Token;
            return token;
        }
    }
}
